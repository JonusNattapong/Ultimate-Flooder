import requests
import re
import os
import datetime
from bs4 import BeautifulSoup
from urllib.parse import urljoin, urlparse
from rich.live import Live
from rich.console import Console, Group
from rich.table import Table
from rich.panel import Panel
from src.utils.logging import add_system_log
from src.utils.ui import create_cyber_progress

console = Console()

def check_content_risk(content):
    """Analyzes response body for high-risk strings"""
    indicators = {
        "DB_PASSWORD|DB_USER|mysqli_connect": "Database Credentials",
        r"eval\(\$_|system\(|passthru\(": "Potential Web Shell",
        "root:x:0:0:": "System Passwords (LFI Success)",
        "AWS_ACCESS_KEY_ID|S3_BUCKET": "Cloud API Keys",
        "BEGIN RSA PRIVATE KEY": "Private SSL/SSH Key",
        "allow_url_include|display_errors": "Dangerous PHP Config"
    }
    
    found_risks = []
    text_content = content.decode('utf-8', errors='ignore')
    for pattern, name in indicators.items():
        if re.search(pattern, text_content, re.IGNORECASE):
            found_risks.append(name)
    return found_risks

def quick_crawler(target_url, limit=5):
    """Finds internal links to expand attack surface"""
    try:
        r = requests.get(target_url, timeout=5)
        soup = BeautifulSoup(r.text, 'html.parser')
        domain = urlparse(target_url).netloc
        links = set()
        for a in soup.find_all('a', href=True):
            full_url = urljoin(target_url, a['href'])
            if urlparse(full_url).netloc == domain:
                links.add(full_url.split('#')[0].rstrip('/'))
        return list(links)[:limit]
    except:
        return []

def detect_waf_and_server(url):
    """Professional-grade WAF and Server fingerprinting"""
    add_system_log(f"[bold cyan]FINGERPRINT:[/] Identifying technology stack for {url}")
    
    findings = {
        "WAF/CDN": "Unknown (Clean or No WAF)",
        "Server": "Unknown",
        "Framework": "Unknown",
        "Security Flags": []
    }
    
    try:
        # Use stealth headers to avoid detection
        from src.utils.network import generate_stealth_headers
        stealth_headers = generate_stealth_headers()
        r = requests.get(url, headers=stealth_headers, timeout=10)
        headers = r.headers
        
        # 1. WAF Detection
        waf_sigs = {
            "cloudflare": "Cloudflare",
            "incapsula": "Imperva Incapsula",
            "sucuri": "Sucuri WAF",
            "mod_security": "ModSecurity",
            "f5": "F5 BIG-IP",
            "fortigate": "Fortinet FortiWeb",
            "akamai": "Akamai CDN",
            "cloudfront": "AWS CloudFront"
        }
        
        for sig, name in waf_sigs.items():
            if sig in str(headers).lower() or sig in str(r.cookies).lower():
                findings["WAF/CDN"] = name
                break
        
        # 2. Server Detection
        findings["Server"] = headers.get("Server", "Hidden")
        
        # 3. Security Headers Check
        if "X-XSS-Protection" not in headers: findings["Security Flags"].append("Missing XSS-Protection")
        if "Content-Security-Policy" not in headers: findings["Security Flags"].append("Missing CSP")
        if "Strict-Transport-Security" not in headers: findings["Security Flags"].append("Missing HSTS")
        
        # 4. Tech Stack (Fingerprinting)
        if "X-Powered-By" in headers: findings["Framework"] = headers["X-Powered-By"]
        elif "wp-content" in r.text: findings["Framework"] = "WordPress"
        elif "django" in str(r.cookies).lower() or "csrftoken" in str(r.cookies).lower(): findings["Framework"] = "Django"
        elif "laravel" in str(r.cookies).lower(): findings["Framework"] = "Laravel"

    except: pass
    return findings

def generate_professional_report(target, fingerprint, exposures, vulnerabilities, cves=None):
    """Generates a professional-grade audit report in HTML format"""
    import datetime
    report_file = f"reports/AUDIT_REPORT_{urlparse(target).netloc}_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.html"
    
    if not os.path.exists('reports'): os.makedirs('reports')
    
    # Simple but professional HTML template
    html = f"""
    <html>
    <head>
        <style>
            body {{ font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; color: #333; max-width: 900px; margin: auto; padding: 20px; }}
            h1 {{ color: #2c3e50; border-bottom: 2px solid #2980b9; padding-bottom: 10px; }}
            .section {{ margin-bottom: 30px; background: #f9f9f9; padding: 15px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
            .high {{ color: #c0392b; font-weight: bold; }}
            table {{ width: 100%; border-collapse: collapse; margin-top: 10px; }}
            th, td {{ padding: 10px; border: 1px solid #ddd; text-align: left; }}
            th {{ background: #2980b9; color: white; }}
            .brand {{ font-size: 0.9em; color: #7f8c8d; text-align: center; margin-top: 50px; }}
        </style>
    </head>
    <body>
        <h1>Security Audit Intelligence Report</h1>
        <p><strong>Target:</strong> {target}</p>
        <p><strong>Scan Date:</strong> {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
        
        <div class="section">
            <h2>üõ° Technology Stack & Fingerprinting</h2>
            <table>
                <tr><th>Component</th><th>Details</th></tr>
                <tr><td>WAF / CDN</td><td>{fingerprint['WAF/CDN']}</td></tr>
                <tr><td>Web Server</td><td>{fingerprint['Server']}</td></tr>
                <tr><td>Technology</td><td>{fingerprint['Framework']}</td></tr>
                <tr><td>Missing Protections</td><td class="high">{', '.join(fingerprint['Security Flags']) if fingerprint['Security Flags'] else 'None (Securely Configured)'}</td></tr>
            </table>
        </div>

        <div class="section">
            <h2>üö® CVE Intelligence (Real-time Database)</h2>
            <table>
                <tr><th>CVE ID</th><th>Summary</th><th>CVSS Score</th></tr>
                {''.join([f"<tr><td class='high'>{cve['id']}</td><td>{cve['summary']}</td><td>{cve['cvss']}</td></tr>" for cve in cves]) if cves else '<tr><td colspan="3">No relevant CVEs found for this technology stack.</td></tr>'}
            </table>
        </div>

        <div class="section">
            <h2>üìÇ Exposed Sensitive Files</h2>
            <table>
                <tr><th>Path</th><th>Status</th><th>Notes</th></tr>
                {''.join([f"<tr><td>{e[0]}</td><td>{e[1]}</td><td>{e[2]}</td></tr>" for e in exposures])}
            </table>
        </div>

        <div class="section">
            <h2>üî• Active Input Vulnerabilities (SQLi/XSS)</h2>
            <table>
                <tr><th>Type</th><th>Parameter</th><th>Payload</th></tr>
                {''.join([f"<tr><td class='high'>{v[0]}</td><td>{v[1]}</td><td><code>{v[2]}</code></td></tr>" for v in vulnerabilities]) if vulnerabilities else '<tr><td colspan="3">No critical input vulnerabilities found.</td></tr>'}
            </table>
        </div>
        
        <div class="brand">Generated by Ultimate Flooder Security Suite - Professional Edition v2.2</div>
    </body>
    </html>
    """
    
    with open(report_file, "w", encoding="utf-8") as f:
        f.write(html)
    return report_file

def smart_fuzzer(url):
    """Fuzzes parameters and forms for common vulnerabilities (SQLi, XSS)"""
    add_system_log(f"[bold yellow]FUZZER:[/] Probing {url} for input vulnerabilities...")
    
    results = []
    
    # Use stealth headers for fuzzing
    from src.utils.network import generate_stealth_headers
    stealth_headers = generate_stealth_headers()
    
    # 1. Test Query Parameters (e.g., ?id=1)
    parsed = urlparse(url)
    params = re.findall(r'([a-zA-Z0-9_]+)=', parsed.query)
    
    sqli_payloads = ["'", "\"", " OR 1=1", " UNION SELECT NULL--"]
    xss_payloads = ["<script>alert(1)</script>", "\"><img src=x onerror=alert(1)>"]
    
    # DB Error strings for SQLi detection
    db_errors = [
        "SQL syntax", "mysql_fetch", "sqlite3.Error", "PostgreSQL query failed",
        "ORA-00933", "Microsoft OLE DB Provider", "unclosed quotation mark"
    ]

    for p in params:
        # SQLi Test
        for pay in sqli_payloads:
            try:
                fuzz_url = url.replace(f"{p}=", f"{p}={pay}")
                r = requests.get(fuzz_url, headers=stealth_headers, timeout=5)
                if any(err in r.text for err in db_errors):
                    results.append(("SQL Injection", p, pay))
                    break # Found one, move to next param
            except: pass
            
        # XSS Test
        for pay in xss_payloads:
            try:
                fuzz_url = url.replace(f"{p}=", f"{p}={pay}")
                r = requests.get(fuzz_url, headers=stealth_headers, timeout=5)
                if pay in r.text:
                    results.append(("XSS (Reflected)", p, pay))
                    break
            except: pass

    # 2. Test Forms (Basic)
    try:
        r = requests.get(url, headers=stealth_headers, timeout=5)
        soup = BeautifulSoup(r.text, 'html.parser')
        forms = soup.find_all('form')
        for form in forms:
            action = form.get('action')
            method = form.get('method', 'get').lower()
            inputs = form.find_all(['input', 'textarea'])
            
            form_url = urljoin(url, action) if action else url
            form_data = {}
            for inp in inputs:
                name = inp.get('name')
                if name: form_data[name] = "fuzz_test"
            
            if form_data:
                # Test each input field in the form
                for field in form_data:
                    for pay in xss_payloads:
                        test_data = form_data.copy()
                        test_data[field] = pay
                        try:
                            if method == 'post':
                                r_form = requests.post(form_url, data=test_data, headers=stealth_headers, timeout=5)
                            else:
                                r_form = requests.get(form_url, params=test_data, headers=stealth_headers, timeout=5)
                            
                            if pay in r_form.text:
                                results.append(("Form XSS", field, pay))
                                break
                        except: pass
    except: pass

    return results

def vulnerability_scout(target_url):
    """Scans for sensitive files and common misconfigurations with Content Analysis"""
    if not target_url.startswith("http"): target_url = f"http://{target_url}"
    
    sensitive_files = [
        ".env", ".git/config", "config.php", "wp-config.php", ".htaccess",
        "phpinfo.php", "info.php", "setup.php", "install.php", "backup.sql",
        "database.sql", "user.sql", "admin/", "cp/", "backup/", ".DS_Store",
        # Backdoor & Shell indicators
        "shell.php", "ws.php", "cmd.php", "c99.php", "r57.php", "b374k.php",
        "wso.php", "simattacker.php", "casper.php", "up.php", "upload.php"
    ]
    
    found = []
    add_system_log(f"[bold cyan]SCOUT:[/] Scanning {target_url} for vulnerabilities")
    
    console.print(f"\n[bold yellow]üîç Analyzing {target_url}...[/bold yellow]")
    
    # Use stealth headers for scanning
    from src.utils.network import generate_stealth_headers
    stealth_headers = generate_stealth_headers()
    
    with create_cyber_progress("[cyan]Sniping Files...[/]") as progress:
        task = progress.add_task("Sniping", total=len(sensitive_files))
        for path in sensitive_files:
            url = f"{target_url.rstrip('/')}/{path}"
            try:
                r = requests.get(url, headers=stealth_headers, timeout=3, allow_redirects=False)
                if r.status_code == 200:
                    risks = check_content_risk(r.content)
                    note = f"Size: {len(r.content)}"
                    if risks:
                        note += f" | [red]RISK: {', '.join(risks)}[/]"
                    found.append((path, r.status_code, note))
                elif r.status_code == 403:
                    found.append((path, 403, "[yellow]Forbidden (Restricted Path)[/]"))
            except:
                pass
            progress.update(task, advance=1)
            
    table = Table(title=f"Vulnerability Report: {target_url}", border_style="red")
    table.add_column("Path", style="cyan")
    table.add_column("Status", style="bold")
    table.add_column("Analysis / Findings", style="white")
    
    if not found:
        table.add_row("No sensitive files found", "-", "-")
    else:
        for f in found:
            status_style = "green" if f[1] == 200 else "yellow"
            table.add_row(f[0], f"[{status_style}]{f[1]}[/]", str(f[2]))
            add_system_log(f"[red]EXPOSURE FOUND:[/] {f[0]} on {target_url}")

    console.print(Panel(table, border_style="red"))
    return found

def brute_force_suite(target, service, username="admin"):
    """Basic credential tester for common services (SSH/FTP/HTTP)"""
    import ftplib
    common_passwords = ["admin", "password", "123456", "admin123", "root", "user", "guest"]
    add_system_log(f"[bold cyan]BRUTE:[/] Starting {service} test on {target}")
    
    found_pass = None
    
    with create_cyber_progress(f"Testing {service} passwords...") as progress:
        task = progress.add_task("Brute Forcing", total=len(common_passwords))
        if service.lower() == "ftp":
            for pwd in common_passwords:
                try:
                    ftp = ftplib.FTP(target, timeout=5)
                    ftp.login(username, pwd)
                    ftp.quit()
                    found_pass = pwd
                    break
                except:
                    pass
                progress.update(task, advance=1)
        
        elif service.lower() == "http":
            for pwd in common_passwords:
                try:
                    r = requests.get(f"http://{target}", auth=(username, pwd), timeout=5)
                    if r.status_code == 200:
                        found_pass = pwd
                        break
                except:
                    pass
                progress.update(task, advance=1)
    
    if found_pass:
        msg = f"[bold green]SUCCESS![/] Found password for [cyan]{username}[/]: [yellow]{found_pass}[/]"
        console.print(Panel(msg, title="Brute Force Result", border_style="green"))
        add_system_log(f"[green]BRUTE SUCCESS:[/] Found credentials for {target}")
    else:
        console.print("[bold red]FAILED:[/] No common passwords match.")

def cve_explorer(keyword):
    """Search for CVEs using CIRCL API with Live Streaming Results"""
    add_system_log(f"[bold cyan]CVE:[/] Searching CVEs for '{keyword}'")
    
    table = Table(
        title=f"üåê [bold white]CVE Intel Database:[/] [magenta]{keyword}[/]", 
        border_style="magenta",
        header_style="bold magenta",
        expand=True
    )
    table.add_column("CVE ID", style="cyan", width=15)
    table.add_column("Summary", style="white")
    table.add_column("CVSS", style="bold red", width=10)

    progress = create_cyber_progress(f"[magenta]Querying CVE Database for {keyword}...[/]", total=None)
    progress.add_task("", total=None)

    with Live(Group(progress, table), refresh_per_second=4) as live:
        try:
            # Using CIRCL CVE Search API
            url = f"https://cve.circl.lu/api/search/{keyword}"
            resp = requests.get(url, timeout=10)
            data = resp.json()
            
            # Hide progress once we have data to start "streaming" it
            progress.stop()

            # Get first 15 results for better visibility
            results = data[:15] if isinstance(data, list) else data.get('results', [])[:15]
            
            if not results:
                table.add_row("No CVEs found", "No matches in database", "N/A")
            else:
                for cve in results:
                    table.add_row(
                        cve.get('id', 'N/A'), 
                        cve.get('summary', 'N/A')[:120] + "...", 
                        str(cve.get('cvss', 'N/A'))
                    )
                    time.sleep(0.1) # Aesthetic delay for streaming effect
        except Exception as e:
            console.print(f"[red]Error searching CVE database: {e}[/]")

def fetch_live_cves(keyword="", limit=5):
    """Fetch latest CVEs from NVD API for real-time vulnerability intelligence"""
    try:
        import requests
        # Using NVD (National Vulnerability Database) API
        url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch={keyword}&resultsPerPage={limit}" if keyword else "https://services.nvd.nist.gov/rest/json/cves/2.0?resultsPerPage=10"
        headers = {'User-Agent': 'Ultimate-Flooder-Security-Suite/2.2'}

        resp = requests.get(url, headers=headers, timeout=15)
        data = resp.json()

        cves = []
        if 'vulnerabilities' in data:
            for vuln in data['vulnerabilities'][:limit]:
                cve = vuln['cve']
                cve_id = cve['id']
                summary = cve.get('descriptions', [{}])[0].get('value', 'No description available')
                cvss_score = 'N/A'

                # Extract CVSS score if available
                if 'metrics' in cve:
                    if 'cvssMetricV31' in cve['metrics']:
                        cvss_score = cve['metrics']['cvssMetricV31'][0]['cvssData']['baseScore']
                    elif 'cvssMetricV30' in cve['metrics']:
                        cvss_score = cve['metrics']['cvssMetricV30'][0]['cvssData']['baseScore']
                    elif 'cvssMetricV2' in cve['metrics']:
                        cvss_score = cve['metrics']['cvssMetricV2'][0]['cvssData']['baseScore']

                cves.append({
                    'id': cve_id,
                    'summary': summary[:100] + "..." if len(summary) > 100 else summary,
                    'cvss': cvss_score,
                    'published': cve.get('published', 'N/A')
                })
        return cves
    except Exception as e:
        add_system_log(f"[red]CVE API Error:[/] {str(e)}")
        return []

def check_cve_relevance(target_tech, cves):
    """Check if any CVEs are relevant to the target's technology stack"""
    relevant = []
    tech_keywords = {
        'apache': ['apache', 'httpd'],
        'nginx': ['nginx'],
        'wordpress': ['wordpress', 'wp'],
        'php': ['php'],
        'mysql': ['mysql', 'mariadb'],
        'cloudflare': ['cloudflare']
    }
    
    for cve in cves:
        summary = cve['summary'].lower()
        for tech, keywords in tech_keywords.items():
            if tech == target_tech.lower() or any(kw in summary for kw in keywords):
                relevant.append(cve)
                break
    
    return relevant

def web_exposure_sniper(target):
    """Deep web exposure scan: Fingerprinting + CVE Intelligence + Fuzzing + Crawler + Pro Report"""
    if not target.startswith("http"): target = f"http://{target}"
    
    add_system_log(f"[bold red]SNIPER:[/] Launching Enterprise-Grade Recon on {target}")
    console.print(Panel(
        f"[bold white]üéØ Target Locked:[/bold white] [green]{target}[/green]\n"
        f"[bold white]Security Suite:[/bold white] Professional Edition v2.2",
        title="[bold red] IP-HUNTER INTEL [/bold red]", border_style="red"
    ))
    
    # 1. Fingerprinting (WAF & Tech Stack)
    with create_cyber_progress("[cyan]üîç Step 1: Technology Fingerprinting...[/cyan]") as progress:
        task = progress.add_task("Fingerprinting")
        fingerprint = detect_waf_and_server(target)
        progress.update(task, advance=100)
    
    f_table = Table(show_header=False, border_style="dim")
    f_table.add_row("WAF/CDN", f"[bold yellow]{fingerprint['WAF/CDN']}[/bold yellow]")
    f_table.add_row("Server", fingerprint['Server'])
    f_table.add_row("Stack", fingerprint['Framework'])
    console.print(f_table)

    # 2. CVE Intelligence (NEW: Real-time vulnerability database)
    with create_cyber_progress("[cyan]üîç Step 2: CVE Intelligence Gathering...[/cyan]") as progress:
        task = progress.add_task("CVE Intelligence")
        detected_tech = fingerprint['Framework'].lower() if fingerprint['Framework'] != "Unknown" else ""
        latest_cves = fetch_live_cves(detected_tech, limit=3)
        relevant_cves = check_cve_relevance(detected_tech, latest_cves)
        progress.update(task, advance=100)
    
    if relevant_cves:
        cve_table = Table(title="üö® Relevant CVEs for This Stack", border_style="bold red")
        cve_table.add_column("CVE ID", style="red")
        cve_table.add_column("Summary", style="white")
        cve_table.add_column("CVSS", style="yellow")
        
        for cve in relevant_cves:
            cve_table.add_row(cve['id'], cve['summary'], str(cve['cvss']))
            add_system_log(f"[bold red]CVE ALERT:[/] {cve['id']} relevant to {detected_tech}")
        
        console.print(Panel(cve_table, border_style="red"))
    else:
        console.print("[dim]No recent CVEs found for this technology stack.[/dim]")

    # 3. File Discovery Pass
    with create_cyber_progress("[cyan]üîç Step 3: Sensitive File Hunting...[/cyan]") as progress:
        task = progress.add_task("File Hunting")
        exposures = vulnerability_scout(target)
        progress.update(task, advance=100)
    
    # 4. Input Fuzzing Pass
    with create_cyber_progress("[cyan]üîç Step 4: Automated Vulnerability Fuzzing...[/cyan]") as progress:
        task = progress.add_task("Fuzzing")
        fuzz_results = smart_fuzzer(target)
        progress.update(task, advance=100)
    
    # 5. Crawler: Expansion Pass
    with create_cyber_progress("[cyan]üîç Step 5: Web Crawling & Expansion...[/cyan]") as progress:
        task = progress.add_task("Crawling")
        sub_links = quick_crawler(target)
        if sub_links:
            for link in sub_links:
                if link != target:
                    if "?" in link: fuzz_results.extend(smart_fuzzer(link))
        progress.update(task, advance=100)
    
    # Final Result & Report Generation
    console.print("\n[bold green]‚úÖ Audit Complete. Generating Professional Intelligence Report...[/bold green]")
    report_path = generate_professional_report(target, fingerprint, exposures, fuzz_results, relevant_cves)
    
    console.print(Panel(
        f"[bold white]Report saved to:[/bold white] [cyan]{report_path}[/cyan]\n"
        f"[dim]You can open this HTML file in any browser for full details.[/dim]",
        title="[bold green] MISSION ACCOMPLISHED [/bold green]", border_style="green"
    ))
    
    add_system_log(f"[green]SNIPER:[/] Report generated: {report_path}")
