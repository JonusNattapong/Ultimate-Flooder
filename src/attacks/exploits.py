import requests
import re
import os
import datetime
from bs4 import BeautifulSoup
from urllib.parse import urljoin, urlparse
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.progress import track
from src.utils.logging import add_system_log

console = Console()

def check_content_risk(content):
    """Analyzes response body for high-risk strings"""
    indicators = {
        "DB_PASSWORD|DB_USER|mysqli_connect": "Database Credentials",
        r"eval\(\$_|system\(|passthru\(": "Potential Web Shell",
        "root:x:0:0:": "System Passwords (LFI Success)",
        "AWS_ACCESS_KEY_ID|S3_BUCKET": "Cloud API Keys",
        "BEGIN RSA PRIVATE KEY": "Private SSL/SSH Key",
        "allow_url_include|display_errors": "Dangerous PHP Config"
    }
    
    found_risks = []
    text_content = content.decode('utf-8', errors='ignore')
    for pattern, name in indicators.items():
        if re.search(pattern, text_content, re.IGNORECASE):
            found_risks.append(name)
    return found_risks

def quick_crawler(target_url, limit=5):
    """Finds internal links to expand attack surface"""
    try:
        r = requests.get(target_url, timeout=5)
        soup = BeautifulSoup(r.text, 'html.parser')
        domain = urlparse(target_url).netloc
        links = set()
        for a in soup.find_all('a', href=True):
            full_url = urljoin(target_url, a['href'])
            if urlparse(full_url).netloc == domain:
                links.add(full_url.split('#')[0].rstrip('/'))
        return list(links)[:limit]
    except:
        return []

def detect_waf_and_server(url):
    """Professional-grade WAF and Server fingerprinting"""
    add_system_log(f"[bold cyan]FINGERPRINT:[/] Identifying technology stack for {url}")
    
    findings = {
        "WAF/CDN": "Unknown (Clean or No WAF)",
        "Server": "Unknown",
        "Framework": "Unknown",
        "Security Flags": []
    }
    
    try:
        r = requests.get(url, timeout=10)
        headers = r.headers
        
        # 1. WAF Detection
        waf_sigs = {
            "cloudflare": "Cloudflare",
            "incapsula": "Imperva Incapsula",
            "sucuri": "Sucuri WAF",
            "mod_security": "ModSecurity",
            "f5": "F5 BIG-IP",
            "fortigate": "Fortinet FortiWeb",
            "akamai": "Akamai CDN",
            "cloudfront": "AWS CloudFront"
        }
        
        for sig, name in waf_sigs.items():
            if sig in str(headers).lower() or sig in str(r.cookies).lower():
                findings["WAF/CDN"] = name
                break
        
        # 2. Server Detection
        findings["Server"] = headers.get("Server", "Hidden")
        
        # 3. Security Headers Check
        if "X-XSS-Protection" not in headers: findings["Security Flags"].append("Missing XSS-Protection")
        if "Content-Security-Policy" not in headers: findings["Security Flags"].append("Missing CSP")
        if "Strict-Transport-Security" not in headers: findings["Security Flags"].append("Missing HSTS")
        
        # 4. Tech Stack (Fingerprinting)
        if "X-Powered-By" in headers: findings["Framework"] = headers["X-Powered-By"]
        elif "wp-content" in r.text: findings["Framework"] = "WordPress"
        elif "django" in str(r.cookies).lower() or "csrftoken" in str(r.cookies).lower(): findings["Framework"] = "Django"
        elif "laravel" in str(r.cookies).lower(): findings["Framework"] = "Laravel"

    except: pass
    return findings

def generate_professional_report(target, fingerprint, exposures, vulnerabilities):
    """Generates a professional-grade audit report in HTML format"""
    import datetime
    report_file = f"reports/AUDIT_REPORT_{urlparse(target).netloc}_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.html"
    
    if not os.path.exists('reports'): os.makedirs('reports')
    
    # Simple but professional HTML template
    html = f"""
    <html>
    <head>
        <style>
            body {{ font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; color: #333; max-width: 900px; margin: auto; padding: 20px; }}
            h1 {{ color: #2c3e50; border-bottom: 2px solid #2980b9; padding-bottom: 10px; }}
            .section {{ margin-bottom: 30px; background: #f9f9f9; padding: 15px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
            .high {{ color: #c0392b; font-weight: bold; }}
            table {{ width: 100%; border-collapse: collapse; margin-top: 10px; }}
            th, td {{ padding: 10px; border: 1px solid #ddd; text-align: left; }}
            th {{ background: #2980b9; color: white; }}
            .brand {{ font-size: 0.9em; color: #7f8c8d; text-align: center; margin-top: 50px; }}
        </style>
    </head>
    <body>
        <h1>Security Audit Intelligence Report</h1>
        <p><strong>Target:</strong> {target}</p>
        <p><strong>Scan Date:</strong> {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
        
        <div class="section">
            <h2>üõ° Technology Stack & Fingerprinting</h2>
            <table>
                <tr><th>Component</th><th>Details</th></tr>
                <tr><td>WAF / CDN</td><td>{fingerprint['WAF/CDN']}</td></tr>
                <tr><td>Web Server</td><td>{fingerprint['Server']}</td></tr>
                <tr><td>Technology</td><td>{fingerprint['Framework']}</td></tr>
                <tr><td>Missing Protections</td><td class="high">{', '.join(fingerprint['Security Flags']) if fingerprint['Security Flags'] else 'None (Securely Configured)'}</td></tr>
            </table>
        </div>

        <div class="section">
            <h2>üìÇ Exposed Sensitive Files</h2>
            <table>
                <tr><th>Path</th><th>Status</th><th>Notes</th></tr>
                {''.join([f"<tr><td>{e[0]}</td><td>{e[1]}</td><td>{e[2]}</td></tr>" for e in exposures])}
            </table>
        </div>

        <div class="section">
            <h2>üî• Active Input Vulnerabilities (SQLi/XSS)</h2>
            <table>
                <tr><th>Type</th><th>Parameter</th><th>Payload</th></tr>
                {''.join([f"<tr><td class='high'>{v[0]}</td><td>{v[1]}</td><td><code>{v[2]}</code></td></tr>" for v in vulnerabilities]) if vulnerabilities else '<tr><td colspan="3">No critical input vulnerabilities found.</td></tr>'}
            </table>
        </div>
        
        <div class="brand">Generated by Ultimate Flooder Security Suite - Professional Edition</div>
    </body>
    </html>
    """
    
    with open(report_file, "w", encoding="utf-8") as f:
        f.write(html)
    return report_file

def smart_fuzzer(url):
    """Fuzzes parameters and forms for common vulnerabilities (SQLi, XSS)"""
    add_system_log(f"[bold yellow]FUZZER:[/] Probing {url} for input vulnerabilities...")
    
    results = []
    
    # 1. Test Query Parameters (e.g., ?id=1)
    parsed = urlparse(url)
    params = re.findall(r'([a-zA-Z0-9_]+)=', parsed.query)
    
    sqli_payloads = ["'", "\"", " OR 1=1", " UNION SELECT NULL--"]
    xss_payloads = ["<script>alert(1)</script>", "\"><img src=x onerror=alert(1)>"]
    
    # DB Error strings for SQLi detection
    db_errors = [
        "SQL syntax", "mysql_fetch", "sqlite3.Error", "PostgreSQL query failed",
        "ORA-00933", "Microsoft OLE DB Provider", "unclosed quotation mark"
    ]

    for p in params:
        # SQLi Test
        for pay in sqli_payloads:
            try:
                fuzz_url = url.replace(f"{p}=", f"{p}={pay}")
                r = requests.get(fuzz_url, timeout=5)
                if any(err in r.text for err in db_errors):
                    results.append(("SQL Injection", p, pay))
                    break # Found one, move to next param
            except: pass
            
        # XSS Test
        for pay in xss_payloads:
            try:
                fuzz_url = url.replace(f"{p}=", f"{p}={pay}")
                r = requests.get(fuzz_url, timeout=5)
                if pay in r.text:
                    results.append(("XSS (Reflected)", p, pay))
                    break
            except: pass

    # 2. Test Forms (Basic)
    try:
        r = requests.get(url, timeout=5)
        soup = BeautifulSoup(r.text, 'html.parser')
        forms = soup.find_all('form')
        for form in forms:
            action = form.get('action')
            method = form.get('method', 'get').lower()
            inputs = form.find_all(['input', 'textarea'])
            
            form_url = urljoin(url, action) if action else url
            form_data = {}
            for inp in inputs:
                name = inp.get('name')
                if name: form_data[name] = "fuzz_test"
            
            if form_data:
                # Test each input field in the form
                for field in form_data:
                    for pay in xss_payloads:
                        test_data = form_data.copy()
                        test_data[field] = pay
                        try:
                            if method == 'post':
                                r_form = requests.post(form_url, data=test_data, timeout=5)
                            else:
                                r_form = requests.get(form_url, params=test_data, timeout=5)
                            
                            if pay in r_form.text:
                                results.append(("Form XSS", field, pay))
                                break
                        except: pass
    except: pass

    return results

def vulnerability_scout(target_url):
    """Scans for sensitive files and common misconfigurations with Content Analysis"""
    if not target_url.startswith("http"): target_url = f"http://{target_url}"
    
    sensitive_files = [
        ".env", ".git/config", "config.php", "wp-config.php", ".htaccess",
        "phpinfo.php", "info.php", "setup.php", "install.php", "backup.sql",
        "database.sql", "user.sql", "admin/", "cp/", "backup/", ".DS_Store",
        # Backdoor & Shell indicators
        "shell.php", "ws.php", "cmd.php", "c99.php", "r57.php", "b374k.php",
        "wso.php", "simattacker.php", "casper.php", "up.php", "upload.php"
    ]
    
    found = []
    add_system_log(f"[bold cyan]SCOUT:[/] Scanning {target_url} for vulnerabilities")
    
    console.print(f"\n[bold yellow]üîç Analyzing {target_url}...[/bold yellow]")
    
    for path in track(sensitive_files, description="[cyan]Sniping Files...[/]"):
        url = f"{target_url.rstrip('/')}/{path}"
        try:
            r = requests.get(url, timeout=3, allow_redirects=False)
            if r.status_code == 200:
                risks = check_content_risk(r.content)
                note = f"Size: {len(r.content)}"
                if risks:
                    note += f" | [red]RISK: {', '.join(risks)}[/]"
                found.append((path, r.status_code, note))
            elif r.status_code == 403:
                found.append((path, 403, "[yellow]Forbidden (Restricted Path)[/]"))
        except:
            continue
            
    table = Table(title=f"Vulnerability Report: {target_url}", border_style="red")
    table.add_column("Path", style="cyan")
    table.add_column("Status", style="bold")
    table.add_column("Analysis / Findings", style="white")
    
    if not found:
        table.add_row("No sensitive files found", "-", "-")
    else:
        for f in found:
            status_style = "green" if f[1] == 200 else "yellow"
            table.add_row(f[0], f"[{status_style}]{f[1]}[/]", str(f[2]))
            add_system_log(f"[red]EXPOSURE FOUND:[/] {f[0]} on {target_url}")

    console.print(Panel(table, border_style="red"))
    return found

def brute_force_suite(target, service, username="admin"):
    """Basic credential tester for common services (SSH/FTP/HTTP)"""
    import ftplib
    common_passwords = ["admin", "password", "123456", "admin123", "root", "user", "guest"]
    add_system_log(f"[bold cyan]BRUTE:[/] Starting {service} test on {target}")
    
    found_pass = None
    
    if service.lower() == "ftp":
        for pwd in track(common_passwords, description=f"Testing {service} passwords"):
            try:
                ftp = ftplib.FTP(target, timeout=5)
                ftp.login(username, pwd)
                ftp.quit()
                found_pass = pwd
                break
            except:
                continue
    
    elif service.lower() == "http":
        for pwd in track(common_passwords, description=f"Testing {service} passwords"):
            try:
                r = requests.get(f"http://{target}", auth=(username, pwd), timeout=5)
                if r.status_code == 200:
                    found_pass = pwd
                    break
            except:
                continue
    
    if found_pass:
        msg = f"[bold green]SUCCESS![/] Found password for [cyan]{username}[/]: [yellow]{found_pass}[/]"
        console.print(Panel(msg, title="Brute Force Result", border_style="green"))
        add_system_log(f"[green]BRUTE SUCCESS:[/] Found credentials for {target}")
    else:
        console.print("[bold red]FAILED:[/] No common passwords match.")

def cve_explorer(keyword):
    """Search for CVEs using CIRCL API"""
    add_system_log(f"[bold cyan]CVE:[/] Searching CVEs for '{keyword}'")
    console.print(f"\n[bold yellow]üîç Searching CVE Database for: {keyword}[/bold yellow]")
    
    try:
        # Using CIRCL CVE Search API
        url = f"https://cve.circl.lu/api/search/{keyword}"
        resp = requests.get(url, timeout=10)
        data = resp.json()
        
        table = Table(title=f"CVE Search Results: {keyword}", border_style="magenta")
        table.add_column("CVE ID", style="cyan")
        table.add_column("Summary", style="white")
        table.add_column("CVSS", style="bold red")

        # Get first 10 results
        results = data[:10] if isinstance(data, list) else data.get('results', [])[:10]
        
        if not results:
            table.add_row("No CVEs found", "-", "-")
        else:
            for cve in results:
                table.add_row(
                    cve.get('id', 'N/A'), 
                    cve.get('summary', 'N/A')[:100] + "...", 
                    str(cve.get('cvss', 'N/A'))
                )
        
        console.print(Panel(table, border_style="magenta"))
    except Exception as e:
        console.print(f"[red]Error searching CVE database: {e}[/]")

def web_exposure_sniper(target):
    """Deep web exposure scan: Fingerprinting + Fuzzing + Crawler + Pro Report"""
    if not target.startswith("http"): target = f"http://{target}"
    
    add_system_log(f"[bold red]SNIPER:[/] Launching Enterprise-Grade Recon on {target}")
    console.print(Panel(
        f"[bold white]üéØ Target Locked:[/bold white] [green]{target}[/green]\n"
        f"[bold white]Security Suite:[/bold white] Professional Edition v2.1",
        title="[bold red] IP-HUNTER INTEL [/bold red]", border_style="red"
    ))
    
    # 1. Fingerprinting (WAF & Tech Stack)
    console.print("\n[bold cyan]üîç Step 1: Technology Fingerprinting...[/bold cyan]")
    fingerprint = detect_waf_and_server(target)
    f_table = Table(show_header=False, border_style="dim")
    f_table.add_row("WAF/CDN", f"[bold yellow]{fingerprint['WAF/CDN']}[/bold yellow]")
    f_table.add_row("Server", fingerprint['Server'])
    f_table.add_row("Stack", fingerprint['Framework'])
    console.print(f_table)

    # 2. File Discovery Pass
    console.print("\n[bold cyan]üîç Step 2: Sensitive File Hunting...[/bold cyan]")
    exposures = vulnerability_scout(target) # Note: Need to update vulnerability_scout to return the 'found' list
    
    # 3. Input Fuzzing Pass
    console.print("\n[bold cyan]üîç Step 3: Automated Vulnerability Fuzzing...[/bold cyan]")
    fuzz_results = smart_fuzzer(target)
    
    # 4. Crawler: Expansion Pass
    console.print("\n[bold cyan]üîç Step 4: Web Crawling & Expansion...[/bold cyan]")
    sub_links = quick_crawler(target)
    if sub_links:
        for link in sub_links:
            if link != target:
                if "?" in link: fuzz_results.extend(smart_fuzzer(link))
    
    # Final Result & Report Generation
    console.print("\n[bold green]‚úÖ Audit Complete. Generating Professional Intelligence Report...[/bold green]")
    report_path = generate_professional_report(target, fingerprint, exposures, fuzz_results)
    
    console.print(Panel(
        f"[bold white]Report saved to:[/bold white] [cyan]{report_path}[/cyan]\n"
        f"[dim]You can open this HTML file in any browser for full details.[/dim]",
        title="[bold green] MISSION ACCOMPLISHED [/bold green]", border_style="green"
    ))
    
    add_system_log(f"[green]SNIPER:[/] Report generated: {report_path}")
